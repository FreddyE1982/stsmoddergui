# GraalPy runtime modding opportunities

The following catalogue expands on the practical gameplay-facing features that become feasible only after enabling the `experimental.graalpy_runtime` feature flag. Each entry highlights the player-facing result alongside the modules and helpers that mod teams can lean on once the GraalPy backend is active.

1. [complete] **Cinematic hand-crafted boss rivalries** – Feed fight telemetry straight into Python-side AI trainers that refine encounter scripts in real time, letting the same GraalPy process push updated intents through `modules.modbuilder.Character` without the latency of JPype marshalling.
2. [complete] **Adaptive card-illustration swaps** – The `experimental.graalpy_adaptive_illustrations` module couples Pillow remaps with `modules.modbuilder.Deck` statistics to recolour cards mid-run based on relics collected, creating a living codex of the player's journey without shipping pre-rendered variants.
3. [complete] **Live tutorial narrator** – Stitch together GraalPy-accessible voice-over queues that react to combat events surfaced by `modules.basemod_wrapper.events`, enabling a fully voiced mentor that comments on draws, discards and power spikes as they happen.
4. [complete] **Coaching ghosts for high-score chases** – Use GraalPy to read and replay leaderboard ghosts, overlaying their actions through the BaseMod wrapper so players duel their past runs or community legends inside the same session. Implemented by `experimental.graalpy_coaching_ghosts` with granular and high-level APIs plus tooling-friendly plugin exposures.
5. **Card-slinger roguelite editor** – Launch an in-run deck tinkerer that applies blueprint edits from a web UI, piping the results through `SimpleCardBlueprint` helpers backed by GraalPy's zero-copy data sharing to patch cards without restarting the JVM.
6. **Multi-language lore drops** – Tap into GraalPy's text-to-speech libraries to narrate dynamic lore snippets when new keywords trigger, relying on the keyword helpers to surface contextual metadata for immersive storytelling beats.
7. **Party-wide sentiment system** – Power a relationship simulator that samples Python sentiment models, feeding updated power modifiers back into combat to reflect how allies feel about the player's choices, all within one GraalVM process.
8. **Reactive dungeon painter** – Bind GraalPy's image generation stack to `Character.validate` analytics so the map art morphs alongside deck archetypes, colouring future encounters and reward screens with bespoke art the moment analytics detect a style shift.
9. **Run historian timelines** – Stream run logs directly into GraalPy-backed dataframes to craft timeline overlays, letting players scrub through card plays, damage spikes, and relic triggers via an in-game panel built on the high-level wrappers.
10. **Collaborative mod trainer** – Expose the full plugin registry through GraalPy so remote teammates can hot-load balancing scripts, share experimental decks via the `Deck.statistics()` output, and iterate together without shipping patched jars.

11. **Polyphonic combat scoring** – Mix adaptive battle music in real time with Python audio suites, piping combat state from `Character` hooks so every playstyle earns its own soundtrack layers without waiting for pre-rendered tracks.
12. **Voice-drafted turns** – Route microphone input through GraalPy's speech recognition stacks to select cards and targets on the fly, relying on `Deck` helpers to validate spoken combos before dispatching BaseMod actions.
13. **Storylet improviser** – Call into narrative generation models during event rolls to craft bespoke dialogue trees, then publish the branches back through the experimental runtime so `Character.createMod` scenes evolve with the player's deck identity.
14. **Forge-by-gesture relic crafting** – Feed live camera frames into GraalPy-friendly computer vision so campfire relic upgrades respond to hand movements, updating relic stats immediately through the high-level wrapper instead of bespoke JNI bridges.
15. **Volatile weather fronts** – Simulate shifting battlefield climates in GraalPy and stream their modifiers into `modules.modbuilder.Deck` snapshots, letting card costs, intents, and visuals pivot with each storm cell mid-combat.
16. **Tactical familiar director** – Train a GraalPy reinforcement agent to pilot an allied familiar that reacts to `Character` telemetry, granting players an autonomous companion with emergent support behaviors that never leave the JVM boundary.
17. **Reflex dodge overlays** – Add time-sensitive evasion prompts computed in Python physics engines, synchronising BaseMod hit windows with GraalPy-rendered overlays so quick reactions earn tangible survival bonuses.
18. **Biome-reactive treasure board** – Analyse `Deck.statistics()` in GraalPy to curate chest contents that reflect the player's archetype, reshaping reward choices instantly without repacking static JSON loot tables.
19. **Market surge shops** – Run micro-economy simulations inside the experimental runtime so shop prices, inventory, and flash sales fluctuate with the run's combat metrics, all orchestrated through the Deck and Character automation helpers.
20. **Dance-pad rituals** – Translate rhythm controller inputs via GraalPy into `Character` campfire rituals that unlock bespoke buffs, making timing-based mini-games a first-class part of the roguelike loop.
21. **Negotiated truces** – Let GraalPy natural-language agents parse player speech and enemy metadata to broker mid-fight treaties, wiring the accepted outcomes back through BaseMod events for branching pacifist endings.
22. **Temporal echo experiments** – Predict future draw orders with GraalPy forecasting models and visualise them in-game, empowering players to preview alternate timelines before committing to a turn.
23. **Emotion-adaptive HUD** – Ingest wearable sentiment feeds through GraalPy so the interface scales clarity, contrast, and tooltip verbosity with the player's stress level, reinforcing accessibility without custom JNI shims.
24. **Cinematic finishing move generator** – Compose bespoke finishing animations by coupling GraalPy animation rigs with `Character` end-of-fight callbacks, ensuring every elite kill lands with hand-authored flair.
25. **Multi-run quest arcs** – Persist GraalPy-authored quest states between runs and stitch them into `Character.createMod` campaigns, unlocking episodic story beats that react to cumulative deck choices.
26. **Haptic accessibility translator** – Drive haptic vests or braille displays directly from GraalPy when status effects trigger, translating `Keyword` data into tactile cues for players who need sensory alternatives.
27. **Infiltration puzzle gauntlets** – Generate stealth or lock-picking microgames on event nodes via GraalPy puzzle solvers, feeding the outcomes back into the deck builder to gate rare relic caches.
28. **Second-screen encounter orchestrator** – Bind websocket spectators to GraalPy coroutines so a dungeon master can spawn hazards or boons in real time, all mediated through the same plugin surface that powers automated mods.
29. **Synergy forecasting coach** – Use GraalPy machine learning to recommend sequencing orders during combat, surfacing suggestions directly within `Deck` tooltips while preserving player agency.
30. **Dynamic challenge board** – Maintain a live scoreboard of optional rule mutations curated by GraalPy services, injecting rotating modifiers into encounters and rewarding compliance with bespoke relics.
31. **Highlight reel studio** – Capture combat telemetry and stream it into GraalPy video editors that export instant shareable clips once a fight ends, showcasing standout plays without external capture software.
32. **Skillshot trajectory simulator** – Leverage GraalPy physics engines to preview projectile-style card effects with on-screen arcs, allowing precise planning of multi-target interactions before committing energy.
33. **Chromatic comfort coach** – Apply GraalPy colour-science libraries to rebalance palette contrasts dynamically, ensuring every combat scene respects the player's accessibility preferences tracked by the runtime.
34. **Audience fate voting** – Sync live poll results from streaming platforms into GraalPy listeners that mutate event outcomes, transforming viewer participation into canonical in-run twists surfaced through the wrapper APIs.
35. **Card memory theatre** – Stitch together GraalPy-rendered dioramas that replay each card's pivotal moments between combats, turning the `Deck` history into an interactive museum the player can walk through.
36. **Wearable-driven energy tuning** – Read heart-rate or motion sensor data via GraalPy to award bonus energy during peak exertion, translating real-world effort into in-game tempo through the automation helpers.
37. **Physical card scanner** – Let players flash printed prototypes at a webcam so GraalPy OCR spawns matching `SimpleCardBlueprint` entries on the fly, turning tabletop sketches into live digital cards mid-run.
38. **Rule-weaver battle mutators** – Execute GraalPy rule scripts that rewrite combat constraints (no skill cards, inverted block, etc.) in response to plugin broadcasts, keeping every encounter unpredictable without recompiling mods.
39. **Campfire escape rooms** – Replace simple rest/upgrade choices with GraalPy-driven spatial puzzles whose solved state determines the next campfire reward tier, enlivening downtime moments through the high-level runtime.
40. **Artifact provenance tracker** – Chronicle each relic's journey by logging combat contributions into GraalPy timelines, then surface narrated flashbacks when relics evolve or combine via `Character` callbacks.

Each scenario above relies on the tighter GraalPy integration to remove cross-runtime overhead, letting the high-level helpers (`Deck`, `Character`, `Keyword`, and the analytics stack) stay responsive even when complex Python-side processing is involved.
